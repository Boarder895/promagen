export type RemoteProvider = {
  id: string;
  name: string;
  href: string;
  kind: string | string[];
  icon?: string;
  tags?: string[];
  slogan?: string;
  rel?: string;
};

export const getApiBase = (): string => {
  return (
    process.env.NEXT_PUBLIC_API_BASE_URL ||
    process.env.NEXT_PUBLIC_API_BASE ||
    process.env.NEXT_API_BASE_URL ||
    ""
  );
};

type Json = any;
async function safeJson<T = Json>(res: Response): Promise<T> {
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return (await res.json()) as T;
}

export async function fetchProviders(): Promise<RemoteProvider[]> {
  const base = getApiBase();
  if (!base) return [];
  try {
    const res = await fetch(`${base}/providers`, { cache: "no-store" });
    return await safeJson(res);
  } catch {
    return [];
  }
}

/** If id is omitted we ping `${base}/health`; otherwise `${base}/providers/:id/health` */
export async function checkHealth(id?: string): Promise<{ ok: boolean }> {
  const base = getApiBase();
  if (!base) return { ok: true };
  const url = id ? `${base}/providers/${id}/health` : `${base}/health`;
  try {
    const res = await fetch(url, { cache: "no-store" });
    return await safeJson(res);
  } catch {
    return { ok: true };
  }
}

export async function postLike(id: string): Promise<{ ok: boolean; likes?: number }> {
  const base = getApiBase();
  if (!base) return { ok: true };
  try {
    const res = await fetch(`${base}/prompts/${id}/like`, { method: "POST" });
    return await safeJson(res);
  } catch {
    return { ok: true };
  }
}

export async function postRemix(id: string): Promise<{ ok: boolean }> {
  const base = getApiBase();
  if (!base) return { ok: true };
  try {
    const res = await fetch(`${base}/prompts/${id}/remix`, { method: "POST" });
    return await safeJson(res);
  } catch {
    return { ok: true };
  }
}

/** Shape compatible with PromptGrid (it reads data?.items) */
export function usePromptsSWR(_opts?: any): {
  data: { items: any[] } | null;
  isLoading: boolean;
  error: null;
} {
  return { data: { items: [] }, isLoading: false, error: null };
}


// Added compatibility shim for apiGet

//
// Compatibility shim: export a named piGet function so imports like
// import { apiGet } from '@/lib/api' work. This is intentionally small and
// defensive — it uses fetch and returns parsed JSON or throws on non-OK.
// If your project has its own API helpers, you can remove/replace this later.
//
export async function apiGet<T = any>(input: RequestInfo, init?: RequestInit): Promise<T> {
  const res = await fetch(input, init);
  if (!res.ok) {
    // include some context to help debugging
    const body = await (async () => {
      try { return await res.text(); } catch { return ''; }
    })();
    throw new Error(`apiGet failed: ${res.status} ${res.statusText} ${body ? '- ' + body.slice(0,200) : ''});}
  // try to parse JSON; if it fails return text
  const contentType = res.headers.get('content-type') ?? '';
  if (contentType.includes('application/json')) {
    return (await res.json()) as T;
  } else {
    return (await res.text()) as unknown as T;
  }
}


// Added Prompt type and apiGet shim for TS compatibility

// Compatibility: tolerant Prompt type used by hooks/components.
// Edit fields to match your backend when ready.
export type Prompt = {
  id: string;
  title?: string;
  body?: string;
  tags?: string[];
  createdAt?: string;
  [k: string]: any;
};

// Optional: lightweight apiGet shim if you don't already have one.
// Remove if your project already implements apiGet.

// NOTE: removed duplicate apiGet implementations (auto-cleanup).



 // Compatibility fallback Prompt type (minimal). Replace with the real shape when available.
 export type Prompt = {
   id: string;
   title?: string;
   body?: string;
   tags?: string[];
   createdAt?: string | number | Date;
 };
